<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detailed Interactive 3D Spaceship</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111122; /* Dark space blue */ }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
    </style>
    <!-- Import map for Three.js modules from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Click and drag to rotate | Scroll/Pinch to zoom</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, spaceshipGroup;

        function init() {
            // Scene
            scene = new THREE.Scene();
            // Fog for atmosphere
            scene.fog = new THREE.Fog(0x111122, 50, 150);


            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30); // Positioned further back and higher

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows for more realism
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606080, 1.5); // Cooler ambient
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Stronger primary light
            sunLight.position.set(20, 30, 15);
            sunLight.castShadow = true; // Enable shadow casting
            // Shadow properties
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;

            scene.add(sunLight);
            // scene.add(new THREE.CameraHelper(sunLight.shadow.camera)); // Optional: Visualize shadow camera

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2 + 0.3; // Allow slightly more angle

            // Create Spaceship
            createDetailedSpaceship();

            // Optional: Add stars
            addStars();

            // Handle Window Resize
            window.addEventListener('resize', onWindowResize, false);

            // Start Animation
            animate();
        }

        function createDetailedSpaceship() {
            spaceshipGroup = new THREE.Group();

            // --- Materials ---
            const greyMetal = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.4 });
            const darkGreyMetal = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
            const orangeAccent = new THREE.MeshStandardMaterial({ color: 0xff8800, metalness: 0.4, roughness: 0.6 });
             const orangeGlow = new THREE.MeshStandardMaterial({
                color: 0xffa500, // Orange
                emissive: 0xffa500, // Make it glow orange
                emissiveIntensity: 1.5
            });
            const cockpitGlass = new THREE.MeshPhysicalMaterial({ // Physical material for better glass
                color: 0x87ceeb, // Sky blue tint
                metalness: 0.1,
                roughness: 0.05,
                transmission: 0.9, // Make it transparent
                transparent: true,
                thickness: 0.5, // Required for transmission
                ior: 1.5 // Index of refraction like glass
            });

            // --- Components ---

            // 1. Main Fuselage (Stretched Box)
            const fuselageGeom = new THREE.BoxGeometry(3.5, 2, 10); // width, height, length
            const fuselageMesh = new THREE.Mesh(fuselageGeom, greyMetal);
            fuselageMesh.castShadow = true;
            fuselageMesh.receiveShadow = true;
            spaceshipGroup.add(fuselageMesh);

            // 2. Cockpit (Box approximation)
            const cockpitGeom = new THREE.BoxGeometry(2.5, 1.5, 3);
            const cockpitMesh = new THREE.Mesh(cockpitGeom, cockpitGlass); // Use glass material
            cockpitMesh.position.set(0, 0.8, 3.5); // Position forward and slightly up
            cockpitMesh.rotation.x = -Math.PI / 18; // Slight downward tilt
            cockpitMesh.castShadow = true;
            spaceshipGroup.add(cockpitMesh);

            // Cockpit Orange Frame (example - very simplified)
            const frameFrontGeom = new THREE.BoxGeometry(2.7, 0.2, 0.2);
            const frameFrontMesh = new THREE.Mesh(frameFrontGeom, orangeAccent);
            frameFrontMesh.position.set(0, 1.4, 4.9); // Adjust position relative to cockpit
            spaceshipGroup.add(frameFrontMesh);
            // Add more frame pieces similarly...

            // 3. Engines (Cylinders with details)
            const engineRadius = 1.8;
            const engineHeight = 5;
            const engineGeom = new THREE.CylinderGeometry(engineRadius, engineRadius * 0.8, engineHeight, 16);
            const engineMaterial = darkGreyMetal;

            // Left Engine
            const leftEngineMesh = new THREE.Mesh(engineGeom, engineMaterial);
            leftEngineMesh.position.set(-3.5, 0, -2); // Position left and back
            leftEngineMesh.rotation.z = Math.PI / 2; // Rotate to point back
            leftEngineMesh.castShadow = true;
            leftEngineMesh.receiveShadow = true;
            spaceshipGroup.add(leftEngineMesh);

            // Right Engine
            const rightEngineMesh = new THREE.Mesh(engineGeom, engineMaterial);
            rightEngineMesh.position.set(3.5, 0, -2); // Position right and back
            rightEngineMesh.rotation.z = Math.PI / 2;
            rightEngineMesh.castShadow = true;
            rightEngineMesh.receiveShadow = true;
            spaceshipGroup.add(rightEngineMesh);

            // Engine Glow (Torus inside)
            const glowGeom = new THREE.TorusGeometry(engineRadius * 0.6, 0.15, 8, 32);
            const leftGlowMesh = new THREE.Mesh(glowGeom, orangeGlow);
            leftGlowMesh.position.set(-3.5, 0, -1.8); // Slightly inside the engine front
            leftGlowMesh.rotation.y = Math.PI / 2;
            spaceshipGroup.add(leftGlowMesh);

            const rightGlowMesh = new THREE.Mesh(glowGeom, orangeGlow);
            rightGlowMesh.position.set(3.5, 0, -1.8);
            rightGlowMesh.rotation.y = Math.PI / 2;
            spaceshipGroup.add(rightGlowMesh);

            // Engine Top Fins (Thin Boxes)
            const finGeom = new THREE.BoxGeometry(1.5, 3, 0.2);
            const leftFinMesh = new THREE.Mesh(finGeom, greyMetal);
            leftFinMesh.position.set(-3.5, engineRadius * 0.9, -2.5); // On top of engine, slightly back
            leftFinMesh.rotation.x = -Math.PI / 6; // Angle slightly
             leftFinMesh.castShadow = true;
            spaceshipGroup.add(leftFinMesh);

            const rightFinMesh = new THREE.Mesh(finGeom, greyMetal);
            rightFinMesh.position.set(3.5, engineRadius * 0.9, -2.5);
            rightFinMesh.rotation.x = -Math.PI / 6;
            rightFinMesh.castShadow = true;
            spaceshipGroup.add(rightFinMesh);


            // 4. Wings (Thin Boxes, swept back)
            const wingWidth = 6;
            const wingDepth = 4;
            const wingThickness = 0.15;
            const wingGeom = new THREE.BoxGeometry(wingWidth, wingThickness, wingDepth);

            // Left Wing
            const leftWingMesh = new THREE.Mesh(wingGeom, orangeAccent); // Orange top material
            leftWingMesh.position.set(- (fuselageGeom.parameters.width / 2 + wingWidth / 2 - 0.5) , -0.3, -1.5); // Attach to side, slightly back
            leftWingMesh.rotation.y = Math.PI / 6; // Sweep back angle
            leftWingMesh.castShadow = true;
            leftWingMesh.receiveShadow = true;
            spaceshipGroup.add(leftWingMesh);

            // Right Wing
            const rightWingMesh = new THREE.Mesh(wingGeom, orangeAccent);
            rightWingMesh.position.set((fuselageGeom.parameters.width / 2 + wingWidth / 2 - 0.5), -0.3, -1.5);
            rightWingMesh.rotation.y = -Math.PI / 6; // Sweep back angle (opposite)
            rightWingMesh.castShadow = true;
            rightWingMesh.receiveShadow = true;
            spaceshipGroup.add(rightWingMesh);

            // 5. Guns (Cylinders under cockpit)
            const gunGeom = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 12);
            const gunMaterial = darkGreyMetal;

            const leftGunMesh = new THREE.Mesh(gunGeom, gunMaterial);
            leftGunMesh.position.set(-0.8, -0.7, 4.5); // Under cockpit, left side
            leftGunMesh.rotation.x = Math.PI / 2; // Point forward
            leftGunMesh.castShadow = true;
            spaceshipGroup.add(leftGunMesh);

            const rightGunMesh = new THREE.Mesh(gunGeom, gunMaterial);
            rightGunMesh.position.set(0.8, -0.7, 4.5); // Under cockpit, right side
            rightGunMesh.rotation.x = Math.PI / 2;
            rightGunMesh.castShadow = true;
            spaceshipGroup.add(rightGunMesh);

            // 6. Top Details (Small Boxes - Simplified)
            const detailGeom = new THREE.BoxGeometry(0.5, 0.4, 0.8);
            for (let i = 0; i < 4; i++) {
                const detailMesh = new THREE.Mesh(detailGeom, orangeAccent);
                detailMesh.position.set((i - 1.5) * 0.7, 1.1, -0.5); // Position on top behind cockpit
                detailMesh.castShadow = true;
                spaceshipGroup.add(detailMesh);
            }


            // Add the whole group to the scene
            scene.add(spaceshipGroup);
            spaceshipGroup.position.y = 1; // Lift the ship slightly off the "ground"
        }

         function addStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                sizeAttenuation: true // Stars get smaller further away
            });

            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(300); // Spread stars across a large area
                const y = THREE.MathUtils.randFloatSpread(300);
                const z = THREE.MathUtils.randFloatSpread(300);
                // Ensure stars are not too close to the center
                if(Math.abs(x) > 20 || Math.abs(y) > 20 || Math.abs(z) > 20) {
                   starVertices.push(x, y, z);
                }

            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls

            // Add subtle automatic rotation for viewing
            if (spaceshipGroup) {
               // spaceshipGroup.rotation.y += 0.002;
            }

            renderer.render(scene, camera);
        }

        // --- Initialize ---
        init();

    </script>
</body>
</html>